## 26. 删除有序数组中的重复项

> [地址](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

给你一个非严格递增排列的数组 `nums`，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k`，你需要做以下事情确保你的题解可以被通过：

更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。 `nums` 的其余元素与 `nums` 的大小不重要。
返回 `k` 。

示例 1：

> 输入：nums = [1,1,2]
>
> 输出：2, nums = [1,2,_]
>
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

示例 2：

>输入：nums = [0,0,1,1,1,2,2,3,3,4]
>
>输出：5, nums = [0,1,2,3,4]
>
>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 

提示：

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums 已按 非严格递增 排列`

### 思路

参照双指针法解答，设立慢指针 `k` 和快指针 `i` ， `i` 作为 `nums` 遍历的索引，将其初始化为 `1` 。当 `nums[i]` 不等于 `nums[k]` 时，则将 `k+1` 并把 `nums[i]` 赋值给 `nums[k]` ，最后返回 `k+1`。

### 通解

为了让解法更具有一般性，我们将原问题的 **「最多保留 1 位」** 修改为 **「最多保留 k 位」**。

对于此类问题，我们应该进行如下考虑：

由于是保留 `k` 个相同数字，对于前 `k` 个数字，我们可以直接保留。
对于后面的任意数字，能够保留的前提是： **与当前写入的位置前面的第 k 个元素进行比较，不相同则保留**。

我们令 `k=1` ，假设有样例： `[3,3,3,3,4,4,4,5,5,5]`

0. 设定变量 `idx` ，指向待插入位置。 `idx` 初始值为 `0` ，目标数组为 `[]`

1. 首先我们先让第 1 位直接保留（性质 1）。 `idx` 变为 `1` ，目标数组为 `[3]`

2. 继续往后遍历，能够保留的前提是与 `idx` 的前面 `1` 位元素不同（性质 2），因此我们会跳过剩余的 `3` ，将第一个 `4` 追加进去。`idx` 变为 `2`，目标数组为 `[3,4]`

3. 继续这个过程，跳过剩余的 `4`，将第一个 `5` 追加进去。 `idx` 变为 `3` ，目标数组为 `[3,4,5]`

4. 当整个数组被扫描完，最终我们得到了目标数组 `[3,4,5]` 和 答案 `idx` 为 `3`。

### 题解

**常规方法**

```javascript

var removeDuplicates = function (nums) {
    if (nums.length === 0) return 0

    let k = 0
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] !== nums[k]) {
            nums[++k] = nums[i]
        }
    }
    return k + 1
};

```

**通解**

```javascript

// k 为保留的项数
var removeDuplicates = function (nums, k) {
    let idx = 0

    for (const i of nums) {
        if (idx < k || nums[idx - k] !== i) nums[idx++] = i
    }
    return idx
};

```

### 关联题目

1. [80. 删除排序数组中的重复项 II](./80.md)